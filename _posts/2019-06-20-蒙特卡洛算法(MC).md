---
layout:     post                    # 使用的布局
title:      蒙特卡洛算法(MC)           # 标题 
subtitle:   蒙特卡洛算法解析 
date:       2019-06-20              # 时间
author:     Jinliang                      # 作者
header-img: img/post-bg-gudian.jpeg    #这篇文章标题背景图片
catalog: true                       # 是否归档
mathjax: true                       #是否显示公式
tags:                               #标签
    - Reinforcement Learning
---

我们来探讨一下强化学习既然是学习，肯定需要数据，数据从哪里来呢？

在DP方法中，数据可以通过精确的**环境模型**获得（转移概率分布）；另一种方法是从**实际经验**中学习，即智能体与环境的交互经验；另一种是通过**仿真经验**学习，在这种情况下，同样需要模型，但是作用是通过模型产生经验数据，而不是直接从转移概率分布获取（目前大多数实验都是从仿真经验学习）。

我们把仅仅通过经验（实际经验、仿真经验）学习的方法叫做**蒙特卡洛法**（Monte Carlo, MC）。MC方法基于**采样回报均值**来估计值函数，并且它的更新往往在一个episode结束才能进行，与DP单步更新的方式不同。



## 1.  蒙特卡洛预测

如何使用MC方法求解给定策略的状态值函数呢？即怎样使用MC方法将一个策略转换成对应的状态值函数（对应着DP方法的策略评估）。

我们从值函数的定义入手：某个状态之后的期望累计回报。

根据统计学的思想，我们可以利用**回报平均值来近似期望回报**，样本数越大，近似值将会收敛到期望值。这就是MC的思想，很简单。（为何不使用DP的方法？因为MC不知道精确的环境模型）

下面就是具体的实施环节了。假设我们要估计$v_\pi(\textbf s)$，我们需要先进行采样，根据一个episode记录同一个状态的值多次还是一次的问题，产生了first-visit MC方法和every-visit MC方法。

- first-visit MC

  在每个episode中仅记录第一次出现的状态对应的值。

- every-visit MC

  在一个episode中，一个状态出现几次就记录几次。

上述两种方法都能收敛到真实值，但是稍微不同：first-visit MC相比于every-visit MC使用广泛，而且是无偏估计，估计的标准差为$\frac{1}{\sqrt n}$，$n$表示$s$在所有episode中出现的次数。every-visit MC更容易联系到后面讲的值函数近似和资格迹。

我们现在使用first-visit MC方法进行值函数预测，伪代码为：

![1560307635130](https://jinliangxx.oss-cn-beijing.aliyuncs.com/2019-06-20-113815.png)

对伪代码进行解读：

1. 输入待评估的策略
2. 随机初始化状态值函数
3. 每个状态初始化一个列表，因为需要采样多次（episode的数量次），每次的值就是列表的一个元素
4. 循环每个episode，根据当前策略产生一条经验
5. 循环episode经验中的每一步，求累计回报（因为求取累计回报需要使用超参数$\gamma$，因此使用小技巧，从后想前求）
6. 将求取的状态的累计回报添加到每个状态的列表中
7. 计算多个episode累计回报的均值（以状态为单位）

我们看一下MC方法的备份图：

![1560308144405](https://jinliangxx.oss-cn-beijing.aliyuncs.com/2019-06-20-113820.png)

我们将MC方法和DP方法进行一下对比：

- DP通过期望的方式更新，MC通过采样
- DP通过下一个状态更新当前状态；MC使用episode中的整条轨迹
- DP是自举的，MC非自举

MC方法的优势：

- 不需要完整的环境模型
- 每个状态值的估计是独立的（通过采样估计，与其他的状态值函数无关）
- 基于回报均值的估计方法是五偏的



## 2. MC动作值函数预测

在第一小节中，我们使用MC方法估计了状态值函数，但是从[状态值函数到策略](https://jinliangxx.github.io/2019/06/10/%E6%9C%89%E9%99%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B-MDP/#4-%E6%9C%80%E4%BC%98%E7%AD%96%E7%95%A5%E5%92%8C%E6%9C%80%E4%BC%98%E5%80%BC%E5%87%BD%E6%95%B0)是需要环境模型的转移概率的，即$\sum_{s',r}p(s',r\mid a,s)$，但是MC方法是不知道环境模型的转移概率的，因此即使求解了最优状态值函数也是无用的。

但是从动作值函数到策略却是不需要知道环境模型的转移概率的，因此本节我们直接使用MC方法估计动作值函数。

使用MC方法估计动作值函数和估计状态值函数的方法是一样的，都是基于回报平均值来近似期望回报，只不过从记录状态对应的回报变成记录状态动作对对应的回报，因为我们估计的是$q_\pi(s,a)$，采样时同样也存在first-visit和every-visit的区别。

但是考虑一个问题，采样动作值函数和采样状态值函数是不一样的，因为在动作值函数中，一个状态对应着多个动作，这样很容易存在某些动作值函数采样不到，而且对于某个确定性策略而言，其在某个状态采取的动作是一样的，这样这个状态下其他的动作永远采样不到，这称为**持续探索**问题。

解决上述问题的方法就是，采样轨迹的初始化状态以非0的概率覆盖到所有的状态动作空间，这样即使采样不到，也能保证初始条件会出现，这个解决办法叫做**探索性开端**。

探索性开端在仿真中可行，但是在实际交互样本中由于事先并不清楚每个状态对应的动作，所以未必满足；

最普遍的方法还是只考虑随机策略，这样某个状态下的所有动作都有其概率，类似于估计状态值函数一样，避免采样不到的问题。



## 3. MC控制

控制指的是如何求解最优策略，类似于DP中的策略提升。

prediction表示预测、评估值函数；control表示通过值函数求解最优策略。

记得在DP方法中，我们提及到[广义策略迭代](https://jinliangxx.github.io/2019/06/11/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#5-%E5%B9%BF%E4%B9%89%E7%AD%96%E7%95%A5%E8%BF%AD%E4%BB%A3generalized)，在MC方法中，同样可以使用广义策略迭代的思想，不断进行策略评估、策略提升两个环节：

![1560323566779](https://jinliangxx.oss-cn-beijing.aliyuncs.com/2019-06-20-113826.png)

在DP方法的广义策略迭代中，策略评估使用的是贝尔曼方程，而我们使用第一、二小节的MC采样求均值方法，而且MC方法评估的是动作值函数。

MC方法的经典策略迭代版本是，先进行策略评估，将策略转换成动作值函数，然后在进行策略提升；不断重复上述两个过程：


$$
\large \pi_0 \xrightarrow{\small E}  q_{\pi_0}  \xrightarrow{\small I}  {\pi_1}   \xrightarrow{\small E}  q_{\pi_1}  \xrightarrow{\small I}  {\pi_2}   \xrightarrow{\small E}  q_{\pi_2}  \xrightarrow{\small I}  {\pi_3}  \dots  \xrightarrow{\small E}  q_{\pi_*}  \xrightarrow{\small I}  {\pi_*} \tag{3-1}
$$


**策略评估**的过程就是第一、二小节的内容；

下面我们来看**策略提升**：


$$
\pi_{k+1}(s) \doteq \arg \max_a q(s,a) \tag{3-2}
$$


公式3-2即策略提升的环节，其实原理和DP的策略提升一样，新的策略就是当前之策略的**贪婪策略**。

根据[策略提升定理](https://jinliangxx.github.io/2019/06/11/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#2-%E7%AD%96%E7%95%A5%E6%8F%90%E5%8D%87)，我们可以证明新策略$\pi_{k+1}(s)$是比当前策略更好的策略：


$$
\begin{align} q_{\pi_k} (s, \pi_{k+1}(s))  &= q_{\pi_k}(s, \arg \max_a q_{\pi_k}(s,a)) \\ &= \max_a q_{\pi_k}(s,a) \\ & \geq v_{\pi_k}(s) \end{align} \tag{3-3}
$$


公式3-3证明我们取当前策略的贪婪策略是满足策略提升定理的。

---

但是第一、二小节的策略评估有着两个缺点：

- 我们使用了探索性开端（解决确定性策略下某些状态动作对访问不到的情况）
- 我们的策略评估进行无数次，无偏的估计出动作值函数

我们先解决第二个缺点，由下面两种解决办法：

- 执行完整的策略评估，但是不追求精确收敛：不需要精确的估计出值函数，而是设置一个误差范围，只要值函数落在误差范围内就认为已经评估完毕。
- 不需要做完整的策略评估，执行若干步甚至是一步（一步就是值迭代）。



解决了第二个假设，我们来看一下当前的MC算法的伪代码：

![1560325578297](https://jinliangxx.oss-cn-beijing.aliyuncs.com/2019-06-20-113848.png)

伪代码解读：

1. 初始化确定性策略
2. 初始化动作值函数
3. 初始化记录采样回报的列表
4. 探索性开端，初始化所有动作值函数不为0
5. 根据当前策略生成一条轨迹
6. 根据当前轨迹通过first-visit的方式采样回报，通过平均值回报的方式估计动作值函数
7. 根据当前估计的动作值函数进行策略提升，即贪婪策略
8. 循环进行5、6、7



## 4. 避免探索性开端

在第三小节中，我们并没有解决探索性开端的问题。

探索性开端指的是在每个episode的初始状态动作，能够覆盖所有可能的状态-动作对，但是这是不显示的，先不说状态动作空间大，在真实环境中，也不可能提前知道所有的状态-动作对。

在解决探索性开端之前，先介绍两个概念：

- on-policy（在策略）：我们估计、提升的策略与决策的策略是同一个策略。
- off-policy（离策略）：相反，我们估计、提升的策略与决策的策略不是同一个策略

我们用$\pi_b$表示决策的策略；$\pi$表示估计、提升的策略。

我们使用探索性开端的原因是确定性策略采样不到所有可能的状态-动作对，但是如果我们的决策策略（即产生轨迹的策略）是随机策略就可以了。

- 在off-policy下

  我们完全可以让决策策略为随机策略，这种就从根本上解决了确定性策略采样不到某些状态-动作对的问题了

- 在on-policy下

  我们需要介绍下面几种策略：

  - soft policy：指的是这个策略能够以大于0的概率取到所有的状态动作对，即$\pi(a \mid s) > 0$，但是，随着时间的推移会越来越趋近一个确定性最优策略。
  - $\epsilon$-soft policy：满足所有状态动作对的概率$\pi(a \mid s) \geq \frac{\epsilon}{\mid \cal A(s) \mid}$.
  - $\epsilon$-greedy policy：以$\epsilon$的概率随机选择所有的动作，以$(1-\epsilon)$的概率贪婪的选择动作。非贪婪的动作被选中的概率为$\frac{\epsilon}{\mid \cal A(s) \mid}$，贪婪动作被选中的概率为$1-\epsilon+\frac{\epsilon}{\mid \cal A(s) \mid}$

  通过上述的概念，我们可知他们是包含关系。

  这样在MC方法中，我们策略评估中的策略可以使用$\epsilon$-soft policy策略，策略提升可以使用$\epsilon$-greedy policy策略，因为前者是包含后者的，后者是前者的贪婪策略。这样我们就能让决策策略和待提升策略为同一个策略，且策略非确定性策略，能够采样到所有的状态-动作对。个人认为这种方法是巧妙的避开了提升策略是确定性策略的条件，但是实际上$\epsilon$-greedy policy不属于完整的策略提升。

  看一下on-policy下的MC算法：

  ![1560394014456](https://jinliangxx.oss-cn-beijing.aliyuncs.com/2019-06-20-113853.png)

  解析一下上述伪代码的流程：

  1. 初始化超参数\epsilon
  2. 初始化\epsilon-soft policy策略\pi
  3. 初始化存储采样回报的列表
  4. 通过策略\pi产生一个episode下的轨迹
  5. 计算轨迹出现的所有动作值函数的平均回报
  6. 使用贪婪策略作为策略提升

  **证明**使用$\epsilon$-greedy policy策略提升能够得到一个更好的策略，并且收敛到最优：

  我们仍然使用策略提升定理，即证明对于新策略$\pi'$满足$q_\pi(s,\pi'(s))\geq v_\pi(s)$:

  
  $$
  \begin{align}
  q_\pi(s, \pi'(s)) &= \sum_a \pi'(a|s) q_\pi (s,a) \\ &= \frac{\varepsilon}{|\mathcal{A}(s)|} \sum_a q_\pi (s,a) + (1-\varepsilon) { \max_a q_\pi (s,a) }  \\ 
  & \geq \frac{\varepsilon}{|\mathcal{A}(s)|} \sum_a q_\pi (s,a) + (1-\varepsilon)  {\sum_a \frac{\pi(a|s) - \frac{\varepsilon}{|\mathcal{A}(s)|}}{1 - \varepsilon} q_\pi (s,a) }  \\ 
  &= \frac{\varepsilon}{|\mathcal{A}(s)|} \sum_a q_\pi (s,a) - \frac{\varepsilon}{|\mathcal{A}(s)|} \sum_a q_\pi (s,a) + \sum_a \pi(a|s) q_\pi(s,a) \\ 
  &= v_\pi(s)  
  \end{align}\tag{4-1}
  $$



​		在公式4-1中，$\pi'$是一个随机策略，我们使用期望值近似$q_\pi(s,\pi'(s))$的值；然后将新的策略$\pi'$看成$\epsilon$-greedy policy，将贪婪策略与非贪婪策略分开求解；变换贪婪部分的表达式为不等式，即缩小贪婪部分；继续展开，最后得出$v_\pi(s)$ 

​		值得注意的是，策略提升的最后收敛的策略是最优策略，但是却是$\epsilon$-soft policy中的最优策略，这也是on-policy下避免探索性开端的代价。



## 5. 在off-policy中使用重要性采样

所有的策略提升中，算法希望学习到最优的策略，但是在学习到最优策略之前，算法需要非最优策略探索所有可能的行为。在on-policy方法中，我们使用了折中的办法，让策略为$\epsilon$-soft policy，但是最终求得的最优策略也仅是$\epsilon$-soft policy的最优策略。按照描述，最适合的方法应该还是off-policy方法，即决策策略和待提升的策略不是一个策略。

在off-policy中，我们将学习的策略叫做**目标策略（target policy）**;决策的策略，即探索策略叫**行为策略（behavior policy）**，我们称之为**离策略学习**（off-policy learning）

在RL中，off-policy和on-policy频繁出现，我们对其进行对比：

- on-policy更加简单、直观，它使用要学习的策略产生数据，再用产生的数据更新策略。但是样本的利用率低，因此早期产生的数据会被抛弃，只有最新的策略产生轨迹参与更新
- off-policy由于产生动作的策略和学习的策略不一样，通常来说方差更大、收敛更慢。但是off-policy方法更加通用强大，我们可以使用任意策略来产生样本，却不用关心学习的策略，这样很容股获得大量的数据。

---

off-policy的预测过程（prediction）：

假如我们现在使用off-policy的方式学习策略，我们的目标策略的状态值函数和动作值函数分别为：$v_\pi(s)、q_\pi(s,a)$，并且已经使用行为策略产生了一些episodes，我们应该如何使用行为策略产生的数据估计目标策略的状态值函数和行为值函数呢？

为了使用策略b产生的数据估计策略$\pi$的值函数，必须满足策略$\pi$选择的动作，b也会选择到，或者说有选择到的可能，因此对于$\pi(a \mid s) > 0$时，必须满足$b(a \mid s)>0$，上述称之为**覆盖假设**。

对于所有的off-policy方法都会用到**重要性采样（important sampling）**。它被用来估计一个分布的估计期望值，而使用其他分部的采样值。

对于离策略学习方法，通过目标策略和行为策略产生采样轨迹的概率比值来对回报进行加权，上述概率成为**重要性采样比**。一条轨迹在策略$\pi$发生的概率为：


$$
Pr \{ A_t, S_{t+1}, A_{t+1}, \dots, S_T | S_t, A_{t:T-1} \sim \pi \}  \\ 
= \pi(A_t| S_t) p(S_{t+1} | S_t, A_t)  {\pi(A_{t+1 } |S_{t+1})} \cdots p(S_T | S_{T-1}, A_{T-1}) \\ 
= \prod_{k=t} ^ {T-1} \pi(A_k | S_k) p(S_{k+1}|S_k, A_k)\tag{4-2}
$$


公式4-2表明，一条轨迹发生的概率等于轨迹上每一个动作状态对发生的概率乘以相邻状态的转移概率。

根据上述结论，求得两个不同策略采样产生同一条轨迹的概率比：


$$
\rho_{t:T-1} \doteq \frac{\prod_{k=t}^{T-1} \pi(A_k | S_k) p(S_{k+1}|S_k, A_k)} {\prod_{k=t}^{T-1} b(A_k | S_k) p(S_{k+1}|S_k, A_k)} = \prod_{k=t}^{T-1} \frac{\pi(A_k|S_k)}{b(A_k|S_k)}  \tag{4-3}
$$


公式4-3表明一个结论，两条轨迹的概率比和环境模型的转移概率$p$是无关的。

有了公式4-3的比例因子，我们就可以把行为策略得到的回报值纠正为目标策略的期望回报，做法如下：


$$
\mathbb{E}[\rho_{t:T-1} G_t | S_t =s ] = v_\pi (s) \tag{4-4}
$$


其中，行为策略的状态值函数为$\mathbb{E}[ G_t | S_t =s ] = v_b (s)$ 。我们已经获得了一个离策略的MC方法，为了区分每个episode中的step，我们将episode连接起来，使用$t$唯一标记特定episode中的特定step。

使用$\cal J(s)$表示状态s被访问对应的时间步；$T(t)$表示时间$t$后首个终止状态对应的步数；$G_t$表示从$t$到$T(t)$的累计回报；$\{G_t\}_{t\in \cal J(s)}$就是所有样本轨迹的回报；$\{ \rho_{t:T(t)-1} \}_{t \in \mathcal{J}(s)}$对应每个$G_t$的重要性采样因子。

根据获得$v_{\pi}(s)$的不同，将重要性采样分为两种类型：

- 常规重要性采样



​	
$$
v_\pi(s) \doteq \frac {\sum_{t \in \mathcal{J}(s)} \rho_{t:T(t)-1} G_t} {|\mathcal{J}(s)|} \tag{4-5}
$$


- 加权重要性采样



​	
$$
v_\pi(s) \doteq \frac {\sum_{t \in \mathcal{J}(s)} \rho_{t:T(t)-1} G_t} {\sum_{t \in \mathcal{J}(s)} \rho_{t:T(t)-1}} \tag{4-6}
$$


两种重要性采样的区别：

- 常规重要性采样是无偏的，加权重要性采样是有偏的
- 常规重要性采样有较大的方差，加权重要性采样方差小

在实际中，因为方差的原因，更推荐使用加权重要性采样。

以上都是针对first-visit方法，对于every-visit方法，两种采样方式都是有偏的。



## 6. 增量式实现（off-policy）

所有基于**采样均值**的方法都有两种实现方式：

- off-line（批方法）

  得到所有采样值，最优一次性的估计值函数

- on-line（增量式方法）

  得到一条采样轨迹更新一次

**常规重要性采样的增量式实现：**

对于常规重要性采样，在正常回报的基础上乘以缩放因子$\rho_{t:T(t)-1}$，然后求均值即可。

可参考之前的[推导]([https://jinliangxx.github.io/2019/05/30/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/#3-%E5%A2%9E%E9%87%8F%E5%BC%8F%E8%AF%84%E4%BC%B0%E8%A1%8C%E4%B8%BA%E5%80%BC%E6%96%B9%E6%B3%95](https://jinliangxx.github.io/2019/05/30/强化学习-基础介绍/#3-增量式评估行为值方法))

公式如下：


$$
Q_{n+1} = Q_n + \frac{1}{n} [\rho G_n  - Q_n]\tag{6-1}
$$


**加权重要性采样的增量式实现：**

当值函数的估计是采用加权重要性采样比的时候，即$V_n \doteq  \frac{\sum_{k=1}^{n-1} W_k G_k}{\sum_{k=1}^{n-1} W_k}$；

$G_k$表示一个序列的回报，$W_k$是相应的权重，即$W_i = \rho_{t_i : T(t_i)-1}$；

我们当前的问题为获取新的$G_n$，如何更新$V$：

引入新的变量C_n，他表示对于每个状态截止当前时刻权重的累计和，即$C_1 = W_1, C_2 = W_1 + W_2, \dots, C_n = W_1 + \dots + W_n$，递推公式为$C_{n+1} = C_n + W_{n+1}$。

增加变量后，值函数增量式更新的公式为：


$$
V_{n+1} \doteq V_n + \frac{W_n}{C_n} [ G_n - V_n] \tag{6-2}
$$


对公式6-2进行简单验证：


$$
\begin{align} V_n + \frac{W_n}{C_n}[G_n - V_n] &= (1 - \frac{W_n}{C_n})V_n + \frac{W_n}{C_n}G_n \\ &= \frac{C_n - W_n}{C_n} \frac{\sum_{k=1}^{n-1} W_k G_k}{\sum_{k=1}^{n-1} W_k} + \frac{W_n G_n}{C_n} \\ &= \frac{C_{n-1}}{C_n}\frac{\sum_{k=1}^{n-1} W_k G_k}{C_{n-1}} + \frac{W_n G_n}{C_n} \\ &= \frac{\sum_{k-1}^n W_k G_k}{C_n}\\ & = V_{n+1} \end{align} \tag{6-3}
$$


根据上述公式推导，我们现在可得出完整的**增量式离策略MC预测算法**，伪代码如下：

![1560942407293](https://jinliangxx.oss-cn-beijing.aliyuncs.com/2019-06-20-113900.png)

## 7. MC控制（off-policy）

第5、6小节介绍了使用MC方法预测（估计）off-policy的值函数，属于预测问题；现在介绍off-policy的MC控制问题，即如何求解最优策略。

总体思路遵守广义策略迭代，交替执行策略估计和策略提升，最终收敛到最优策略和最优值函数。

策略估计如第6节所示，策略提升使用贪婪的确定性策略，因为使用off-policy的原因，完全可以是行为策略为随机策略，目标策略为确定性策略。

下面来看off-policy完整的MC伪代码：

![1561016654949](https://jinliangxx.oss-cn-beijing.aliyuncs.com/2019-06-20-113904.png)

其中需要注意的问题是：中间增加了覆盖性假设的验证

## 8. 总结

在上述的学习中，MC方法通过采样回报均值来学习值函数和最优策略。

相比于之前学习的DP方法，它有着下面几个优点：

- 直接通过与环境交互学习，因此不需要准确知道环境模型，直接通过仿真或者采样模型（sample models）
- 使用MC方法，我们可以只聚焦于一个子状态空间，例如我们感兴趣的状态；DP方法理论上需要遍历装个状态空间
- 不严格依赖于马尔科夫性，在DP和TD方法中，都需要通过后续状态值来更新当前状态，这与马尔科夫性有关，DP与TD方法依赖这个假设，即需要自举。MC方法通过采样回报均值实现，因此不受影响。

MC方法同样使用广义策略迭代的方法不断更新策略与值函数。在预测，即策略估计阶段，MC方法使用采样均值的方法，而不是依赖贝尔曼方程，并且由于MC方法不知道环境模型，因此估计状态值函数得不到相应的策略，所以MC方法估计的是动作值函数。采样均值可以批量的以episode为单位进行更新，也可以使用增量式每一步进行更新。

MC通过采样回报均值的方法估计值函数，一个重要的点就是任何保证充分的探索。一个简单的办法就是使用

**探索性开端**，但是在某些情况下不切实际。因此引入了off-policy机制，让行为策略为随机策略已保证充分探索，目标策略为确定性策略，进行优化提升。但是直接使用off-policy，会使得估计不准确，引入了重要性采样技术。

MC方法的两个重要特点：

- 不使用准确的环境模型
- 不自举

上述内容主要参考《Reinforcement Learning An Introduction》一书。