---
layout:     post                    # 使用的布局
title:      java-内存区域           # 标题 
subtitle:   Java中的内存区域解析       #副标题
date:       2017-09-08              # 时间
author:     原创                      # 作者
header-img: img/post-bg-android.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - Java
---

首先看一张图片，显示了java虚拟机运行时数据区：
![java虚拟机运行时数据区](http://img.blog.csdn.net/20170905142058584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZnVzaGFvbmlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 

 - **程序计数器**
    是一块较小的内存空间，他可以看做是当前线程所执行的字节码的行号指示器。
     字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。

  **java虚拟机的多线程**是通过线程轮流切换并分配处理器执行时间的方式来实现的。为了线程切换后能恢复到正确的位置，每条线程都需咬一个独立的程序计数器，各条线程之间线程计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

	如果线程正在执行一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，这个计数器值则为空。此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError（内存溢出）情况的区域。

 - **java虚拟机栈**
    java虚拟机栈也是线程私有的，他的生命周期和线程相同。
     虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
     每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
     局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、dpuble）、对象引用和returnAddress类型（指向了一条字节码指令的地址）。
     在java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈）如果扩展时无法申请到足够的内存，就会跑出OutOfMemoryError异常。

 - **本地方法栈**
    与虚拟机栈发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行java方法（也就是字节码服务）服务，而本地方法栈则为虚拟机使用到的Native方法服务。
     在虚拟机规范中对本地方法栈中方法使用的语言、使用方式、与数据结构并没有强制规定，因此虚拟机可以自由的实现它。
     有的虚拟机直接把本地方法栈和虚拟机栈合二为一，如：Sun HotSpot
     与虚拟机栈一样，本地方法栈也会抛出：StackOverflowError和OutOfMemeoryError异常。

 - **java堆**
    java堆是java虚拟机管理的内存中最大的一块。
     java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
     此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。（但不是绝对哦，随着技术的发展，所有的对象不一定分配在堆内存上）。
     java堆是垃圾收集器管理的重要区域，因此也被称为“GC堆”。
     根据java虚拟机规范规定，java堆可以出于物理上不连续的内存空间内，只要逻辑上连续的即可，就像我们的磁盘空间一样。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

 - **方法区**
    方法去与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
     java虚拟机规范把方法区描述为堆的一个逻辑部分，但是他却有一个别名叫非堆，目的应该是与java堆区分开来。
     java虚拟机规范对方法区的限制非常宽松，出了和java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少见的，但并非数据进入了方法区就如永久代IDE名字一样“永久”存在了。这个区域的内存回收的目标主要是针对常量池的回收和对类型的卸载，虽然回收的结果难以令人满意，但是确实是有必要的，因为发生过没有回收导致的内存泄漏。
     当方法区无法满足内存分配的需求时，抛出OutOfMemoryError异常。

 - **运行时常量池**
  是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息时常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
  一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。
  运行时常量池相对于常量池的另一个重要特性是具备动态性，运行期也可以将新的常量放入池中，这种特性被开发人员利用的比较多的便是String类的intern()方法。
  无法申请到内存时，也会抛出OutOfMemoryError异常。
