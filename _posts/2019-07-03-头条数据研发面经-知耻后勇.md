---
layout:     post                    # 使用的布局
title:      头条数据研发面经-知耻后勇           # 标题 
subtitle:   菜是原罪 
date:       2019-07-03              # 时间
author:     Jinliang                      # 作者
header-img: img/post-bg-baichi.jpeg    #这篇文章标题背景图片
catalog: true                       # 是否归档
mathjax: true                       #是否显示公式
tags:                               #标签
    - Campus Recruitment
---

面试题目顺序记不太清了，我将按照算法题、基础题的步骤书写，尽量将能够回忆到的都写上。

## 一面

#### 1. 算法：分层返回二叉树

![image-20190703094602766](https://jinliangxx.oss-cn-beijing.aliyuncs.com/2019-07-03-014602.png)

如上图所示二叉树，返回二维数组[[3],[4,5],[5,4,7]]

分析：相当于二叉树的顺序遍历，不过要注意保证每一层单独一个数组保存，且顺序一致，个人认为应该属于简单题。

使用队列保存下一层的节点（注意顺序），然后每次取队列数据之前，先获取当前的长度（即每一层的个数），不然队列是动态增加的。

粘一下伪代码：

```python
from queue import Queue

from typing import List

class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

class Solution:

    def get_list(self, root: Node) -> List[List[int]]:
        result = list()
        if not root:
            return result
        que = Queue()
        que.put(root)
        while que:
            length = que.qsize()
            now_list = list()
            for _ in range(length):
                node = que.get()
                now_list.append(node.val)
                if node.left:
                    que.put(node.left)
                if node.right:
                    que.put(node.right)
            result.append(now_list)
        return result
```



#### 2. 算法：在第一题的条件上，返回路径

即返回二维数组[[3,4,5],[3,4,4,],[3,5,7]]

分析：这个题目中二维数组的长度应该是叶子节点的个数，相同于统计根节点到每个叶子节点，第一直觉就是用递归来做，存储叶子节点之前的信息（在面试时很难想到新思路，几乎是吃平时刷题的经验，因为面试时比较紧张，且时间较短，若将近10分钟没有下笔，面试官会询问~）

同样粘伪代码：

```python
from typing import List


class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None


class Solution:

    def get_list_2(self, root: Node) -> List[List[int]]:
        if not root.left and not root.right:
            return [[root.val]]
        else:
            now_list = [[]]
            if root.left:
                now_list.extend(self.get_list_2(root.left))
            if root.right:
                now_list.extend((self.get_list_2(root.right)))
            for nums in now_list:
                nums.insert(0, root.val)
            return now_list
```



#### 3. 算法：没有重复元素数组，最大长度为31，求全部子集

输入：[1,3,5]

输出：[[],[1],[3],[5],[1,3],[1,5],[3,5],[1,3,5]]

分析：这个题面试官有引导（怪自己太菜），若数组长度为n，则子集的个数应为$2^n$，而求取子集时，可以按照每一位是否保留的思想，转换为二进制的问题，即求0到2^n之间的所有数，每个数转化为二进制，当二进制的index对应位置为1时，代表选取这个元素，0相反。

伪代码：

```python
class Solution:

    def get_list3(self, nums: List[int]) -> List[List[int]]:
        result = list()
        for num in range(2 ** len(nums)):
            nows = list()
            s = bin(num)
            for i, char in enumerate(s):
                if char == '1':
                    nows.append(nums[i])
            result.append(nows)
        return result
```

代码很简单，但是思路很难想，其中代码中转换为二进制求1可以优化，使用位运算：

```python
class Solution:

    def get_list4(self, nums: List[int]) -> List[List[int]]:
        result = list()
        for num in range(2 ** len(nums)):
            nows = list()
            index = 0
            while num >= 1:
                if num & 1 == 1:
                    nows.append(nums[index])
                index += 1
                num >>= 1
            result.append(nows)
        return result
```

使用位运算优化并没有要求写，但是讨论时说到了。



#### 4. 基础：mysql 联合索引

这个题之前看到过，但是太久没准备，加上研究生平时用不到，只记得左面的优先，引以为戒，下面总结一下：

其实核心是最左前缀原则，总结blog的很多，就不重新写了，附上一个比较详细的。

联合索引：https://blog.csdn.net/abysscarry/article/details/80792876

#### 5. 基础：b+树

忘了，重新捡起来

https://zhuanlan.zhihu.com/p/27700617

https://blog.csdn.net/xlgen157387/article/details/79450295

讲的时候注意根据原理，陈述优点与缺点

#### 6. 基础：事务隔离级别

https://tech.meituan.com/2014/08/20/innodb-lock.html

#### 7. 基础：TCP四次挥手

https://blog.csdn.net/qzcsu/article/details/72861891

#### 8. 基础：HashMap实现、线程安全

[https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/](https://yikun.github.io/2015/04/01/Java-HashMap工作原理及实现/)

https://yemengying.com/2016/05/07/threadsafe-hashmap/

#### 9. 基础：梯度下降

[https://jinliangxx.github.io/2019/05/01/%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/](https://jinliangxx.github.io/2019/05/01/常见的优化算法/)



## 二面

#### 1. 算法：链表反转

有递归解法和非递归解法，现场写了非递归的，属于简单题，不过注意边界条件。

#### 2. 算法：top k

使用小顶堆，没有现场写，说了一下思路

https://blog.csdn.net/luochoudan/article/details/53736752

#### 3. 基础：java多线程实现方式

简单说了一下Thread、Runable，第三种忘了叫啥了，实在是记不得那么详细了，复习一下

#### 4. 项目：spark内存压缩

个人的项目，关于spark内存压缩和优化

#### 5. 基础：es界面导入机制

除了RESTAPI还有啥？没搞懂

#### 6. 基础：同步异步、阻塞非阻塞

https://www.cnblogs.com/Anker/p/5965654.html

#### 7. 基础：unix中I/O模型

自己的只是盲区

https://blog.csdn.net/lihao21/article/details/51620374

#### 8. 基础：线程池java参数

完全忘了

https://www.cnblogs.com/dolphin0520/p/3932921.html

#### 9. 基础：LRU

https://zhuanlan.zhihu.com/p/34133067

二面的经历很痛苦，因为面试官着重考察基础支持，特别是java的，之前也没复习java，吸取教训



## 三面

#### 1. 算法：抽奖系统

题目：一共有100万人，每个人有一个id，且每个人有一个概率倍数(1~30)，相当于能抽几次奖奖品共有100份，每人最多中奖一次，要求实现抽奖过程

最开始的思路是算出总票数，然后每个人依次开始抽奖，抽到奖或者自己次数使用完毕，这个人就下去，下一个人开始，伪代码如下：

```python
class Solution:

    def get_list_5(self, peoples: dict) -> List[int]:
        length, start, result = sum(peoples.values()), 0, list()
        tickets = [0 for _ in range(length - 100)]
        tickets.extend([1 for _ in range(100)])
        for people in peoples:
            for _ in range(peoples[people]):
                index = random.randint(start, length)
                tickets[start], tickets[index] = tickets[index], tickets[start]
                if tickets[start] == 1:
                    result.append(people)
                    start += 1
                    break
                start += 1
        return result
```

但是这样做，有可能出现后面的人还没抽奖，奖品就已经被抽完的情况，所以不是很公平，与面试官讨论，最终确定采取摇号的方式：

```python
class Solution:

    def get_list_6(self, peoples: dict) -> List[int]:
        length, start, result = sum(peoples.values()), 0, list()
        tickets = [i for i in range(length)]
        for people in peoples:
            peoples[people] = tickets[start:start + peoples[people]]
            start += peoples[people]
        start = 0
        for _ in range(100):
            index = random.randint(start, len(tickets))
            for people in peoples:
                if tickets[index] in peoples[people]:
                    result.append(people)
                    for num in peoples[people]:
                        tickets[start], tickets[num] = tickets[num], tickets[start]
                    break
        return result
```

#### 2. 项目

剩下的时间都是聊项目，主要考察整体思路、架构，与实现细节，以及为什么这样实现等等。



## HR面

#### 1. 聊基本情况

#### 2. 对工作的要求

#### 3. 意愿城市

#### 4. 有没有其他offer

#### 5. 来自哪里